{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A lightweight PostGIS based dynamic vector tile server. Documentation : developmentseed.org/timvt/ Source Code : developmentseed/timvt TiMVT , pronounced tee-MVT , is a python package which helps creating lightweight Vector Tiles service from PostGIS Database. Built on top of the modern and fast FastAPI framework, timvt is written in Python using async/await asynchronous code to improve the performances and handle heavy loads. TiMVT is mostly inspired from the awesome urbica/martin and CrunchyData/pg_tileserv projects. Features \u00b6 Multiple TileMatrixSets via morecantile . Default is set to WebMercatorQuad which is the usual Web Mercator projection used in most of Wep Map libraries.) Built with FastAPI Table and Function layers Async API using asyncpg Install \u00b6 Install TiMVT from pypi # update pip (optional) python -m pip install pip -U # install timvt python -m pip install timvt or install from source: $ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ python -m pip install -e . PostGIS/Postgres \u00b6 TiMVT rely mostly on ST_AsMVT function and will need PostGIS >= 2.5. If you want more info about ST_AsMVT function or on the subject of creating Vector Tile from PostGIS, please read this great article from Paul Ramsey: info.crunchydata.com/blog/dynamic-vector-tiles-from-postgis Configuration \u00b6 To be able to create Vector Tile, the application will need access to the PostGIS database. TiMVT uses starlette 's configuration pattern which make use of environment variable and/or .env file to pass variable to the application. Example of .env file can be found in .env.example POSTGRES_USER=username POSTGRES_PASS=password POSTGRES_DBNAME=postgis POSTGRES_HOST=0.0.0.0 POSTGRES_PORT=5432 # Or you can also define the DATABASE_URL directly DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis Minimal Application \u00b6 from timvt.db import close_db_connection , connect_to_db from timvt.factory import VectorTilerFactory from fastapi import FastAPI , Request # Create Application. app = FastAPI () # Register Start/Stop application event handler to setup/stop the database connection @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , # add Functions metadata endpoints (/functions.json, /{function_name}.json) with_viewer = True , ) app . include_router ( mvt_tiler . router , tags = [ \"Tiles\" ]) Default Application \u00b6 While we encourage users to write their own application using TiMVT package, we also provide a default production ready application: # Install timvt dependencies and Uvicorn (a lightning-fast ASGI server) $ pip install timvt 'uvicorn[standard]>=0.12.0,<0.14.0' # Set Database URL environment variable so TiMVT can access it $ export DATABASE_URL = postgresql://username:password@0.0.0.0:5432/postgis # Launch Demo Application $ uvicorn timvt.main:app --reload You can also use the official docker image $ docker run \\ -p 8081:8081 \\ -e PORT=8081 \\ -e DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis \\ ghcr.io/developmentseed/timvt:latest :endpoint:/docs Contribution & Development \u00b6 See CONTRIBUTING.md License \u00b6 See LICENSE Authors \u00b6 Created by Development Seed Changes \u00b6 See CHANGES.md .","title":"TiMVT"},{"location":"#features","text":"Multiple TileMatrixSets via morecantile . Default is set to WebMercatorQuad which is the usual Web Mercator projection used in most of Wep Map libraries.) Built with FastAPI Table and Function layers Async API using asyncpg","title":"Features"},{"location":"#install","text":"Install TiMVT from pypi # update pip (optional) python -m pip install pip -U # install timvt python -m pip install timvt or install from source: $ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ python -m pip install -e .","title":"Install"},{"location":"#postgispostgres","text":"TiMVT rely mostly on ST_AsMVT function and will need PostGIS >= 2.5. If you want more info about ST_AsMVT function or on the subject of creating Vector Tile from PostGIS, please read this great article from Paul Ramsey: info.crunchydata.com/blog/dynamic-vector-tiles-from-postgis","title":"PostGIS/Postgres"},{"location":"#configuration","text":"To be able to create Vector Tile, the application will need access to the PostGIS database. TiMVT uses starlette 's configuration pattern which make use of environment variable and/or .env file to pass variable to the application. Example of .env file can be found in .env.example POSTGRES_USER=username POSTGRES_PASS=password POSTGRES_DBNAME=postgis POSTGRES_HOST=0.0.0.0 POSTGRES_PORT=5432 # Or you can also define the DATABASE_URL directly DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis","title":"Configuration"},{"location":"#minimal-application","text":"from timvt.db import close_db_connection , connect_to_db from timvt.factory import VectorTilerFactory from fastapi import FastAPI , Request # Create Application. app = FastAPI () # Register Start/Stop application event handler to setup/stop the database connection @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , # add Functions metadata endpoints (/functions.json, /{function_name}.json) with_viewer = True , ) app . include_router ( mvt_tiler . router , tags = [ \"Tiles\" ])","title":"Minimal Application"},{"location":"#default-application","text":"While we encourage users to write their own application using TiMVT package, we also provide a default production ready application: # Install timvt dependencies and Uvicorn (a lightning-fast ASGI server) $ pip install timvt 'uvicorn[standard]>=0.12.0,<0.14.0' # Set Database URL environment variable so TiMVT can access it $ export DATABASE_URL = postgresql://username:password@0.0.0.0:5432/postgis # Launch Demo Application $ uvicorn timvt.main:app --reload You can also use the official docker image $ docker run \\ -p 8081:8081 \\ -e PORT=8081 \\ -e DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis \\ ghcr.io/developmentseed/timvt:latest :endpoint:/docs","title":"Default Application"},{"location":"#contribution-development","text":"See CONTRIBUTING.md","title":"Contribution &amp; Development"},{"location":"#license","text":"See LICENSE","title":"License"},{"location":"#authors","text":"Created by Development Seed","title":"Authors"},{"location":"#changes","text":"See CHANGES.md .","title":"Changes"},{"location":"contributing/","text":"Development - Contributing \u00b6 Issues and pull requests are more than welcome: github.com/developmentseed/timvt/issues dev install $ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ pip install -e . [ dev ] pre-commit This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install Docs \u00b6 $ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Development - Contributing"},{"location":"contributing/#development-contributing","text":"Issues and pull requests are more than welcome: github.com/developmentseed/timvt/issues dev install $ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ pip install -e . [ dev ] pre-commit This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install","title":"Development - Contributing"},{"location":"contributing/#docs","text":"$ git clone https://github.com/developmentseed/timvt.git $ cd timvt $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Docs"},{"location":"function_layers/","text":"As for pg_tileserv and martin , TiMVT can support Function layer/source. Functions are database functions which can be use to create vector tile and must of the form function(xmin float, ymin float, xmax float, ymax: float, epsg: integer ...) . Minimal Application \u00b6 from timvt.db import close_db_connection , connect_to_db from timvt.factory import VectorTilerFactory from timvt.functions import registry as FunctionRegistry from timvt.layer import Function from fastapi import FastAPI , Request # Create TiMVT Application. app = FastAPI () # Register Start/Stop application event handler to setup/stop the database connection @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register Function to the internal registery FunctionRegistry . register ( Function . from_file ( id = \"squares\" , # By default TiMVT will call a function call `squares` infile = \"my_sql_file.sql\" , # PATH TO SQL FILE ) ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , # add Functions metadata endpoints (/functions.json, /{function_name}.json) with_viewer = True , ) app . include_router ( mvt_tiler . router , tags = [ \"Tiles\" ]) Function Options \u00b6 When registering a Function , the user can set different options: id (required): name of the Layer which will then be used in the endpoint routes. infile (required): path to the SQL code function_name : name of the SQL function within the SQL code. Defaults to id . bounds : Bounding Box for the area of usage (this is for documentation only). minzoom : minimum zoom level (this is for documentation only). maxzoom : maximum zoom level (this is for documentation only). options : List of options available per function (this is for documentation only). # Function with Options FunctionRegistry . register ( Function . from_file ( id = \"squares2\" , infile = \"my_sql_file.sql\" , # PATH TO SQL FILE function_name = \"squares_but_not_squares\" , # This allows to call a specific function within the SQL code bounds = [ 0.0 , 0.0 , 180.0 , 90.0 ], # overwrite default bounds minzoom = 9 , # overwrite default minzoom maxzoom = 24 , # overwrite default maxzoom options = { # Provide arguments information for documentation { \"name\" : \"depth\" , \"default\" : 2 } } ) ) Function Layer Examples \u00b6 Dynamic Geometry Example \u00b6 Goal: Sub-divide input BBOX in smaller squares. CREATE OR REPLACE FUNCTION squares ( -- mandatory parameters xmin float , ymin float , xmax float , ymax float , epsg integer , -- additional parameters depth integer default 2 ) RETURNS bytea AS $$ DECLARE result bytea ; sq_width float ; bbox_xmin float ; bbox_ymin float ; bounds geometry ; bounds_merc geometry ; BEGIN -- Find the bbox bounds bounds : = ST_MakeEnvelope ( xmin , ymin , xmax , ymax , epsg ); -- Find the bottom corner of the bounds bbox_xmin : = ST_XMin ( bounds ); bbox_ymin : = ST_YMin ( bounds ); -- We want bbox divided up into depth*depth squares per bbox, -- so what is the width of a square? sq_width : = ( ST_XMax ( bounds ) - ST_XMin ( bounds )) / depth ; WITH mvtgeom AS ( SELECT -- Fill in the bbox with all the squares ST_AsMVTGeom ( ST_SetSRID ( ST_MakeEnvelope ( bbox_xmin + sq_width * ( a - 1 ), bbox_ymin + sq_width * ( b - 1 ), bbox_xmin + sq_width * a , bbox_ymin + sq_width * b ), epsg ), bounds ) -- Drive the square generator with a two-dimensional -- generate_series setup FROM generate_series ( 1 , depth ) a , generate_series ( 1 , depth ) b ) SELECT ST_AsMVT ( mvtgeom . * , 'default' ) -- Put the query result into the result variale. INTO result FROM mvtgeom ; -- Return the answer RETURN result ; END ; $$ LANGUAGE 'plpgsql' IMMUTABLE -- Same inputs always give same outputs STRICT -- Null input gets null output PARALLEL SAFE ; Custom Function layer \u00b6 So You already have an SQL function written but it only takes WebMercator XYZ indexes. In TiMVT we use bbox+tms to support multiple TMS but you could support simple XYZ functions by writing custom Layer class and dependencies. custom Function Layer # custom.py from typing import Any import morecantile from buildpg import asyncpg from timvt import layer class Function ( layer . Function ): \"Custom Function Layer: SQL function takes xyz input.\"\"\" async def get_tile ( self , pool : asyncpg . BuildPgPool , tile : morecantile . Tile , tms : morecantile . TileMatrixSet , # tms won't be used here ** kwargs : Any , ): \"\"\"Custom Get Tile method.\"\"\" async with pool . acquire () as conn : transaction = conn . transaction () await transaction . start () await conn . execute ( self . sql ) function_params = \":x, :y, :z\" if kwargs : params = \", \" . join ([ f \" { k } => { v } \" for k , v in kwargs . items ()]) function_params += f \", { params } \" content = await conn . fetchval_b ( f \"SELECT { self . function_name } ( { function_params } )\" , x = tile . x , y = tile . y , z = tile . z , ) await transaction . rollback () return content custom registery , referencing the custom Function # custom_registery.py from dataclasses import dataclass from typing import ClassVar , Dict from .custom import Function @dataclass class Registry : \"\"\"function registry\"\"\" funcs : ClassVar [ Dict [ str , Function ]] = {} @classmethod def get ( cls , key : str ): \"\"\"lookup function by name\"\"\" return cls . funcs . get ( key ) @classmethod def register ( cls , * args : Function ): \"\"\"register function(s)\"\"\" for func in args : cls . funcs [ func . id ] = func registry = Registry () custom dependencies # custom_dependencies.py import re from enum import Enum from fastapi import HTTPException , Path from starlette.requests import Request from morecantile import TileMatrixSet , tms from timvt.layer import Layer from .custom_registery import registry as FunctionRegistry # Custom TileMatrixSets deps (only support WebMercatorQuad) TileMatrixSetNames = Enum ( # type: ignore \"TileMatrixSetNames\" , [( \"WebMercatorQuad\" , \"WebMercatorQuad\" )] ) def TileMatrixSetParams ( TileMatrixSetId : TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad , # type: ignore description = \"TileMatrixSet Name\" , ), ) -> TileMatrixSet : \"\"\"TileMatrixSet parameters.\"\"\" return tms . get ( TileMatrixSetId . name ) # Custom Layer Params def LayerParams ( request : Request , layer : str = Path ( ... , description = \"Layer Name\" ), ) -> Layer : \"\"\"Return Layer Object.\"\"\" func = FunctionRegistry . get ( layer ) if func : return func else : table_pattern = re . match ( # type: ignore r \"^(?P<schema>.+)\\.(?P<table>.+)$\" , layer ) if not table_pattern : raise HTTPException ( status_code = 404 , detail = f \"Invalid Table format ' { layer } '.\" ) assert table_pattern . groupdict ()[ \"schema\" ] assert table_pattern . groupdict ()[ \"table\" ] for r in request . app . state . table_catalog : if r [ \"id\" ] == layer : return Table ( ** r ) raise HTTPException ( status_code = 404 , detail = f \"Table/Function ' { layer } ' not found.\" ) Custom Application # custom_app.py from timvt.db import close_db_connection , connect_to_db from timvt.factory import TMSFactory , VectorTilerFactory from fastapi import FastAPI from .custom_dependencies import LayerParams , TileMatrixSetParams , TileMatrixSetNames app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , with_viewer = True , tms_dependency = TileMatrixSetParams , layer_dependency = LayerParams , ) app . include_router ( mvt_tiler . router ) tms = TMSFactory ( supported_tms = TileMatrixSetNames , tms_dependency = TileMatrixSetParams ) app . include_router ( tms . router , tags = [ \"TileMatrixSets\" ])","title":"Function Layers"},{"location":"function_layers/#minimal-application","text":"from timvt.db import close_db_connection , connect_to_db from timvt.factory import VectorTilerFactory from timvt.functions import registry as FunctionRegistry from timvt.layer import Function from fastapi import FastAPI , Request # Create TiMVT Application. app = FastAPI () # Register Start/Stop application event handler to setup/stop the database connection @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register Function to the internal registery FunctionRegistry . register ( Function . from_file ( id = \"squares\" , # By default TiMVT will call a function call `squares` infile = \"my_sql_file.sql\" , # PATH TO SQL FILE ) ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , # add Functions metadata endpoints (/functions.json, /{function_name}.json) with_viewer = True , ) app . include_router ( mvt_tiler . router , tags = [ \"Tiles\" ])","title":"Minimal Application"},{"location":"function_layers/#function-options","text":"When registering a Function , the user can set different options: id (required): name of the Layer which will then be used in the endpoint routes. infile (required): path to the SQL code function_name : name of the SQL function within the SQL code. Defaults to id . bounds : Bounding Box for the area of usage (this is for documentation only). minzoom : minimum zoom level (this is for documentation only). maxzoom : maximum zoom level (this is for documentation only). options : List of options available per function (this is for documentation only). # Function with Options FunctionRegistry . register ( Function . from_file ( id = \"squares2\" , infile = \"my_sql_file.sql\" , # PATH TO SQL FILE function_name = \"squares_but_not_squares\" , # This allows to call a specific function within the SQL code bounds = [ 0.0 , 0.0 , 180.0 , 90.0 ], # overwrite default bounds minzoom = 9 , # overwrite default minzoom maxzoom = 24 , # overwrite default maxzoom options = { # Provide arguments information for documentation { \"name\" : \"depth\" , \"default\" : 2 } } ) )","title":"Function Options"},{"location":"function_layers/#function-layer-examples","text":"","title":"Function Layer Examples"},{"location":"function_layers/#dynamic-geometry-example","text":"Goal: Sub-divide input BBOX in smaller squares. CREATE OR REPLACE FUNCTION squares ( -- mandatory parameters xmin float , ymin float , xmax float , ymax float , epsg integer , -- additional parameters depth integer default 2 ) RETURNS bytea AS $$ DECLARE result bytea ; sq_width float ; bbox_xmin float ; bbox_ymin float ; bounds geometry ; bounds_merc geometry ; BEGIN -- Find the bbox bounds bounds : = ST_MakeEnvelope ( xmin , ymin , xmax , ymax , epsg ); -- Find the bottom corner of the bounds bbox_xmin : = ST_XMin ( bounds ); bbox_ymin : = ST_YMin ( bounds ); -- We want bbox divided up into depth*depth squares per bbox, -- so what is the width of a square? sq_width : = ( ST_XMax ( bounds ) - ST_XMin ( bounds )) / depth ; WITH mvtgeom AS ( SELECT -- Fill in the bbox with all the squares ST_AsMVTGeom ( ST_SetSRID ( ST_MakeEnvelope ( bbox_xmin + sq_width * ( a - 1 ), bbox_ymin + sq_width * ( b - 1 ), bbox_xmin + sq_width * a , bbox_ymin + sq_width * b ), epsg ), bounds ) -- Drive the square generator with a two-dimensional -- generate_series setup FROM generate_series ( 1 , depth ) a , generate_series ( 1 , depth ) b ) SELECT ST_AsMVT ( mvtgeom . * , 'default' ) -- Put the query result into the result variale. INTO result FROM mvtgeom ; -- Return the answer RETURN result ; END ; $$ LANGUAGE 'plpgsql' IMMUTABLE -- Same inputs always give same outputs STRICT -- Null input gets null output PARALLEL SAFE ;","title":"Dynamic Geometry Example"},{"location":"function_layers/#custom-function-layer","text":"So You already have an SQL function written but it only takes WebMercator XYZ indexes. In TiMVT we use bbox+tms to support multiple TMS but you could support simple XYZ functions by writing custom Layer class and dependencies. custom Function Layer # custom.py from typing import Any import morecantile from buildpg import asyncpg from timvt import layer class Function ( layer . Function ): \"Custom Function Layer: SQL function takes xyz input.\"\"\" async def get_tile ( self , pool : asyncpg . BuildPgPool , tile : morecantile . Tile , tms : morecantile . TileMatrixSet , # tms won't be used here ** kwargs : Any , ): \"\"\"Custom Get Tile method.\"\"\" async with pool . acquire () as conn : transaction = conn . transaction () await transaction . start () await conn . execute ( self . sql ) function_params = \":x, :y, :z\" if kwargs : params = \", \" . join ([ f \" { k } => { v } \" for k , v in kwargs . items ()]) function_params += f \", { params } \" content = await conn . fetchval_b ( f \"SELECT { self . function_name } ( { function_params } )\" , x = tile . x , y = tile . y , z = tile . z , ) await transaction . rollback () return content custom registery , referencing the custom Function # custom_registery.py from dataclasses import dataclass from typing import ClassVar , Dict from .custom import Function @dataclass class Registry : \"\"\"function registry\"\"\" funcs : ClassVar [ Dict [ str , Function ]] = {} @classmethod def get ( cls , key : str ): \"\"\"lookup function by name\"\"\" return cls . funcs . get ( key ) @classmethod def register ( cls , * args : Function ): \"\"\"register function(s)\"\"\" for func in args : cls . funcs [ func . id ] = func registry = Registry () custom dependencies # custom_dependencies.py import re from enum import Enum from fastapi import HTTPException , Path from starlette.requests import Request from morecantile import TileMatrixSet , tms from timvt.layer import Layer from .custom_registery import registry as FunctionRegistry # Custom TileMatrixSets deps (only support WebMercatorQuad) TileMatrixSetNames = Enum ( # type: ignore \"TileMatrixSetNames\" , [( \"WebMercatorQuad\" , \"WebMercatorQuad\" )] ) def TileMatrixSetParams ( TileMatrixSetId : TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad , # type: ignore description = \"TileMatrixSet Name\" , ), ) -> TileMatrixSet : \"\"\"TileMatrixSet parameters.\"\"\" return tms . get ( TileMatrixSetId . name ) # Custom Layer Params def LayerParams ( request : Request , layer : str = Path ( ... , description = \"Layer Name\" ), ) -> Layer : \"\"\"Return Layer Object.\"\"\" func = FunctionRegistry . get ( layer ) if func : return func else : table_pattern = re . match ( # type: ignore r \"^(?P<schema>.+)\\.(?P<table>.+)$\" , layer ) if not table_pattern : raise HTTPException ( status_code = 404 , detail = f \"Invalid Table format ' { layer } '.\" ) assert table_pattern . groupdict ()[ \"schema\" ] assert table_pattern . groupdict ()[ \"table\" ] for r in request . app . state . table_catalog : if r [ \"id\" ] == layer : return Table ( ** r ) raise HTTPException ( status_code = 404 , detail = f \"Table/Function ' { layer } ' not found.\" ) Custom Application # custom_app.py from timvt.db import close_db_connection , connect_to_db from timvt.factory import TMSFactory , VectorTilerFactory from fastapi import FastAPI from .custom_dependencies import LayerParams , TileMatrixSetParams , TileMatrixSetNames app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): \"\"\"Application startup: register the database connection and create table list.\"\"\" await connect_to_db ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event (): \"\"\"Application shutdown: de-register the database connection.\"\"\" await close_db_connection ( app ) # Register endpoints. mvt_tiler = VectorTilerFactory ( with_tables_metadata = True , with_functions_metadata = True , with_viewer = True , tms_dependency = TileMatrixSetParams , layer_dependency = LayerParams , ) app . include_router ( mvt_tiler . router ) tms = TMSFactory ( supported_tms = TileMatrixSetNames , tms_dependency = TileMatrixSetParams ) app . include_router ( tms . router , tags = [ \"TileMatrixSets\" ])","title":"Custom Function layer"},{"location":"release-notes/","text":"Release Notes \u00b6 0.2.0 (TBD) \u00b6 Faster and cleaner SQL code Compare Tile and Table geometries in Table CRS (speedup) Allow non-epsg based TileMatrixSet update morecantile requirement to >=3.0.2 add geometry_srid in Table metadata 0.1.0 (2021-10-12) \u00b6 Initial release","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#020-tbd","text":"Faster and cleaner SQL code Compare Tile and Table geometries in Table CRS (speedup) Allow non-epsg based TileMatrixSet update morecantile requirement to >=3.0.2 add geometry_srid in Table metadata","title":"0.2.0 (TBD)"},{"location":"release-notes/#010-2021-10-12","text":"Initial release","title":"0.1.0 (2021-10-12)"},{"location":"api/timvt/db/","text":"Module timvt.db \u00b6 timvt.db: database events. None Variables \u00b6 DATABASE_URL DB_MAX_CONN_SIZE DB_MAX_INACTIVE_CONN_LIFETIME DB_MAX_QUERIES DB_MIN_CONN_SIZE Functions \u00b6 close_db_connection \u00b6 def close_db_connection ( app : fastapi . applications . FastAPI ) -> None Close connection. connect_to_db \u00b6 def connect_to_db ( app : fastapi . applications . FastAPI ) -> None Connect. table_index \u00b6 def table_index ( db_pool : buildpg . asyncpg . BuildPgPool ) -> Sequence Fetch Table index.","title":"db"},{"location":"api/timvt/db/#module-timvtdb","text":"timvt.db: database events. None","title":"Module timvt.db"},{"location":"api/timvt/db/#variables","text":"DATABASE_URL DB_MAX_CONN_SIZE DB_MAX_INACTIVE_CONN_LIFETIME DB_MAX_QUERIES DB_MIN_CONN_SIZE","title":"Variables"},{"location":"api/timvt/db/#functions","text":"","title":"Functions"},{"location":"api/timvt/db/#close_db_connection","text":"def close_db_connection ( app : fastapi . applications . FastAPI ) -> None Close connection.","title":"close_db_connection"},{"location":"api/timvt/db/#connect_to_db","text":"def connect_to_db ( app : fastapi . applications . FastAPI ) -> None Connect.","title":"connect_to_db"},{"location":"api/timvt/db/#table_index","text":"def table_index ( db_pool : buildpg . asyncpg . BuildPgPool ) -> Sequence Fetch Table index.","title":"table_index"},{"location":"api/timvt/dependencies/","text":"Module timvt.dependencies \u00b6 TiVTiler.dependencies: endpoint's dependencies. None Functions \u00b6 LayerParams \u00b6 def LayerParams ( request : starlette . requests . Request , layer : str = Path ( Ellipsis ) ) -> timvt . layer . Layer Return Layer Object. TileMatrixSetParams \u00b6 def TileMatrixSetParams ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters. TileParams \u00b6 def TileParams ( z : int = Path ( Ellipsis ), x : int = Path ( Ellipsis ), y : int = Path ( Ellipsis ) ) -> morecantile . commons . Tile Tile parameters. Classes \u00b6 TileMatrixSetNames \u00b6 class TileMatrixSetNames ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 enum.Enum Class variables \u00b6 CanadianNAD83_LCC EuropeanETRS89_LAEAQuad LINZAntarticaMapTilegrid NZTM2000 NZTM2000Quad UPSAntarcticWGS84Quad UPSArcticWGS84Quad UTM31WGS84Quad WGS1984Quad WebMercatorQuad WorldCRS84Quad WorldMercatorWGS84Quad name value","title":"dependencies"},{"location":"api/timvt/dependencies/#module-timvtdependencies","text":"TiVTiler.dependencies: endpoint's dependencies. None","title":"Module timvt.dependencies"},{"location":"api/timvt/dependencies/#functions","text":"","title":"Functions"},{"location":"api/timvt/dependencies/#layerparams","text":"def LayerParams ( request : starlette . requests . Request , layer : str = Path ( Ellipsis ) ) -> timvt . layer . Layer Return Layer Object.","title":"LayerParams"},{"location":"api/timvt/dependencies/#tilematrixsetparams","text":"def TileMatrixSetParams ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters.","title":"TileMatrixSetParams"},{"location":"api/timvt/dependencies/#tileparams","text":"def TileParams ( z : int = Path ( Ellipsis ), x : int = Path ( Ellipsis ), y : int = Path ( Ellipsis ) ) -> morecantile . commons . Tile Tile parameters.","title":"TileParams"},{"location":"api/timvt/dependencies/#classes","text":"","title":"Classes"},{"location":"api/timvt/dependencies/#tilematrixsetnames","text":"class TileMatrixSetNames ( / , * args , ** kwargs )","title":"TileMatrixSetNames"},{"location":"api/timvt/dependencies/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/timvt/dependencies/#class-variables","text":"CanadianNAD83_LCC EuropeanETRS89_LAEAQuad LINZAntarticaMapTilegrid NZTM2000 NZTM2000Quad UPSAntarcticWGS84Quad UPSArcticWGS84Quad UTM31WGS84Quad WGS1984Quad WebMercatorQuad WorldCRS84Quad WorldMercatorWGS84Quad name value","title":"Class variables"},{"location":"api/timvt/factory/","text":"Module timvt.factory \u00b6 timvt.endpoints.factory: router factories. None Variables \u00b6 TILE_RESPONSE_PARAMS templates Classes \u00b6 TMSFactory \u00b6 class TMSFactory ( supported_tms : Type [ timvt . dependencies . TileMatrixSetNames ] = < enum 'TileMatrixSetNames' > , tms_dependency : Callable [ ... , morecantile . models . TileMatrixSet ] = < function TileMatrixSetParams at 0x7f561b226c10 > , router : fastapi . routing . APIRouter = < factory > , router_prefix : str = '' ) Class variables \u00b6 router_prefix supported_tms Methods \u00b6 register_routes \u00b6 def register_routes ( self ) Register TMS endpoint routes. tms_dependency \u00b6 def tms_dependency ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters. url_for \u00b6 def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific endpoint. VectorTilerFactory \u00b6 class VectorTilerFactory ( router : fastapi . routing . APIRouter = < factory > , tms_dependency : Callable [ ... , morecantile . models . TileMatrixSet ] = < function TileMatrixSetParams at 0x7f561b226c10 > , layer_dependency : Callable [ ... , timvt . layer . Layer ] = < function LayerParams at 0x7f561b0b9d30 > , with_tables_metadata : bool = False , with_functions_metadata : bool = False , with_viewer : bool = False , router_prefix : str = '' ) Class variables \u00b6 router_prefix with_functions_metadata with_tables_metadata with_viewer Methods \u00b6 layer_dependency \u00b6 def layer_dependency ( request : starlette . requests . Request , layer : str = Path ( Ellipsis ) ) -> timvt . layer . Layer Return Layer Object. register_functions_metadata \u00b6 def register_functions_metadata ( self ) Register function metadata endpoints. register_routes \u00b6 def register_routes ( self ) Register Routes. register_tables_metadata \u00b6 def register_tables_metadata ( self ) Register metadata endpoints. register_tiles \u00b6 def register_tiles ( self ) Register /tiles endpoints. register_viewer \u00b6 def register_viewer ( self ) Register viewer. tms_dependency \u00b6 def tms_dependency ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters. url_for \u00b6 def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific endpoint.","title":"factory"},{"location":"api/timvt/factory/#module-timvtfactory","text":"timvt.endpoints.factory: router factories. None","title":"Module timvt.factory"},{"location":"api/timvt/factory/#variables","text":"TILE_RESPONSE_PARAMS templates","title":"Variables"},{"location":"api/timvt/factory/#classes","text":"","title":"Classes"},{"location":"api/timvt/factory/#tmsfactory","text":"class TMSFactory ( supported_tms : Type [ timvt . dependencies . TileMatrixSetNames ] = < enum 'TileMatrixSetNames' > , tms_dependency : Callable [ ... , morecantile . models . TileMatrixSet ] = < function TileMatrixSetParams at 0x7f561b226c10 > , router : fastapi . routing . APIRouter = < factory > , router_prefix : str = '' )","title":"TMSFactory"},{"location":"api/timvt/factory/#class-variables","text":"router_prefix supported_tms","title":"Class variables"},{"location":"api/timvt/factory/#methods","text":"","title":"Methods"},{"location":"api/timvt/factory/#register_routes","text":"def register_routes ( self ) Register TMS endpoint routes.","title":"register_routes"},{"location":"api/timvt/factory/#tms_dependency","text":"def tms_dependency ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters.","title":"tms_dependency"},{"location":"api/timvt/factory/#url_for","text":"def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific endpoint.","title":"url_for"},{"location":"api/timvt/factory/#vectortilerfactory","text":"class VectorTilerFactory ( router : fastapi . routing . APIRouter = < factory > , tms_dependency : Callable [ ... , morecantile . models . TileMatrixSet ] = < function TileMatrixSetParams at 0x7f561b226c10 > , layer_dependency : Callable [ ... , timvt . layer . Layer ] = < function LayerParams at 0x7f561b0b9d30 > , with_tables_metadata : bool = False , with_functions_metadata : bool = False , with_viewer : bool = False , router_prefix : str = '' )","title":"VectorTilerFactory"},{"location":"api/timvt/factory/#class-variables_1","text":"router_prefix with_functions_metadata with_tables_metadata with_viewer","title":"Class variables"},{"location":"api/timvt/factory/#methods_1","text":"","title":"Methods"},{"location":"api/timvt/factory/#layer_dependency","text":"def layer_dependency ( request : starlette . requests . Request , layer : str = Path ( Ellipsis ) ) -> timvt . layer . Layer Return Layer Object.","title":"layer_dependency"},{"location":"api/timvt/factory/#register_functions_metadata","text":"def register_functions_metadata ( self ) Register function metadata endpoints.","title":"register_functions_metadata"},{"location":"api/timvt/factory/#register_routes_1","text":"def register_routes ( self ) Register Routes.","title":"register_routes"},{"location":"api/timvt/factory/#register_tables_metadata","text":"def register_tables_metadata ( self ) Register metadata endpoints.","title":"register_tables_metadata"},{"location":"api/timvt/factory/#register_tiles","text":"def register_tiles ( self ) Register /tiles endpoints.","title":"register_tiles"},{"location":"api/timvt/factory/#register_viewer","text":"def register_viewer ( self ) Register viewer.","title":"register_viewer"},{"location":"api/timvt/factory/#tms_dependency_1","text":"def tms_dependency ( TileMatrixSetId : timvt . dependencies . TileMatrixSetNames = Query ( TileMatrixSetNames . WebMercatorQuad ) ) -> morecantile . models . TileMatrixSet TileMatrixSet parameters.","title":"tms_dependency"},{"location":"api/timvt/factory/#url_for_1","text":"def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific endpoint.","title":"url_for"},{"location":"api/timvt/functions/","text":"Module timvt.functions \u00b6 TiVTiler.functions: custom functions None Variables \u00b6 registry Classes \u00b6 Registry \u00b6 class Registry ( ) Class variables \u00b6 funcs Static methods \u00b6 get \u00b6 def get ( key : str ) lookup function by name register \u00b6 def register ( * args : timvt . layer . Function ) register function(s)","title":"functions"},{"location":"api/timvt/functions/#module-timvtfunctions","text":"TiVTiler.functions: custom functions None","title":"Module timvt.functions"},{"location":"api/timvt/functions/#variables","text":"registry","title":"Variables"},{"location":"api/timvt/functions/#classes","text":"","title":"Classes"},{"location":"api/timvt/functions/#registry","text":"class Registry ( )","title":"Registry"},{"location":"api/timvt/functions/#class-variables","text":"funcs","title":"Class variables"},{"location":"api/timvt/functions/#static-methods","text":"","title":"Static methods"},{"location":"api/timvt/functions/#get","text":"def get ( key : str ) lookup function by name","title":"get"},{"location":"api/timvt/functions/#register","text":"def register ( * args : timvt . layer . Function ) register function(s)","title":"register"},{"location":"api/timvt/layer/","text":"Module timvt.layer \u00b6 timvt Metadata models. None Variables \u00b6 DEFAULT_MAXZOOM DEFAULT_MINZOOM MAX_FEATURES_PER_TILE TILE_BUFFER TILE_RESOLUTION Classes \u00b6 Function \u00b6 class Function ( __pydantic_self__ , ** data : Any ) Attributes \u00b6 Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None type str Layer's type. None function_name str Nane of the SQL function to call. Defaults to id . id sql str Valid SQL function which returns Tile data. None options list options available for the SQL function. None Ancestors (in MRO) \u00b6 timvt.layer.Layer pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_file \u00b6 def from_file ( id : str , infile : str , ** kwargs : Any ) load sql from file from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' function_name_default \u00b6 def function_name_default ( values ) Define default function's name to be same as id. parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. get_tile \u00b6 def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) Get Tile Data. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Layer \u00b6 class Layer ( __pydantic_self__ , ** data : Any ) Attributes \u00b6 Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Descendants \u00b6 timvt.layer.Table timvt.layer.Function Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. get_tile \u00b6 def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) -> bytes Return Tile Data. Parameters: Name Type Description Default pool asyncpg.BuildPgPool AsyncPG database connection pool. None tile morecantile.Tile Tile object with X,Y,Z indices. None tms morecantile.TileMatrixSet Tile Matrix Set. None kwargs any, optiona Optional parameters to forward to the SQL function. None Returns: Type Description bytes Mapbox Vector Tiles. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Table \u00b6 class Table ( __pydantic_self__ , ** data : Any ) Attributes \u00b6 Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None type str Layer's type. None schema str Table's database schema (e.g public). None geometry_type str Table's geometry type (e.g polygon). None srid int Table's SRID None geometry_column str Name of the geomtry column in the table. None properties Dict Properties available in the table. None Ancestors (in MRO) \u00b6 timvt.layer.Layer pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. get_tile \u00b6 def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) Get Tile Data. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"layer"},{"location":"api/timvt/layer/#module-timvtlayer","text":"timvt Metadata models. None","title":"Module timvt.layer"},{"location":"api/timvt/layer/#variables","text":"DEFAULT_MAXZOOM DEFAULT_MINZOOM MAX_FEATURES_PER_TILE TILE_BUFFER TILE_RESOLUTION","title":"Variables"},{"location":"api/timvt/layer/#classes","text":"","title":"Classes"},{"location":"api/timvt/layer/#function","text":"class Function ( __pydantic_self__ , ** data : Any )","title":"Function"},{"location":"api/timvt/layer/#attributes","text":"Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None type str Layer's type. None function_name str Nane of the SQL function to call. Defaults to id . id sql str Valid SQL function which returns Tile data. None options list options available for the SQL function. None","title":"Attributes"},{"location":"api/timvt/layer/#ancestors-in-mro","text":"timvt.layer.Layer pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/layer/#class-variables","text":"Config","title":"Class variables"},{"location":"api/timvt/layer/#static-methods","text":"","title":"Static methods"},{"location":"api/timvt/layer/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/layer/#from_file","text":"def from_file ( id : str , infile : str , ** kwargs : Any ) load sql from file","title":"from_file"},{"location":"api/timvt/layer/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/layer/#function_name_default","text":"def function_name_default ( values ) Define default function's name to be same as id.","title":"function_name_default"},{"location":"api/timvt/layer/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/layer/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/layer/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/layer/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/layer/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/layer/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/layer/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/layer/#methods","text":"","title":"Methods"},{"location":"api/timvt/layer/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/layer/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/layer/#get_tile","text":"def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) Get Tile Data.","title":"get_tile"},{"location":"api/timvt/layer/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/layer/#layer","text":"class Layer ( __pydantic_self__ , ** data : Any )","title":"Layer"},{"location":"api/timvt/layer/#attributes_1","text":"Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None","title":"Attributes"},{"location":"api/timvt/layer/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/layer/#descendants","text":"timvt.layer.Table timvt.layer.Function","title":"Descendants"},{"location":"api/timvt/layer/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/timvt/layer/#static-methods_1","text":"","title":"Static methods"},{"location":"api/timvt/layer/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/layer/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/layer/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/layer/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/layer/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/layer/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/layer/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/layer/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/layer/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/layer/#methods_1","text":"","title":"Methods"},{"location":"api/timvt/layer/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/layer/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/layer/#get_tile_1","text":"def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) -> bytes Return Tile Data. Parameters: Name Type Description Default pool asyncpg.BuildPgPool AsyncPG database connection pool. None tile morecantile.Tile Tile object with X,Y,Z indices. None tms morecantile.TileMatrixSet Tile Matrix Set. None kwargs any, optiona Optional parameters to forward to the SQL function. None Returns: Type Description bytes Mapbox Vector Tiles.","title":"get_tile"},{"location":"api/timvt/layer/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/layer/#table","text":"class Table ( __pydantic_self__ , ** data : Any )","title":"Table"},{"location":"api/timvt/layer/#attributes_2","text":"Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None minzoom int Layer's min zoom level. None maxzoom int Layer's max zoom level. None tileurl str Layer's tiles url. None type str Layer's type. None schema str Table's database schema (e.g public). None geometry_type str Table's geometry type (e.g polygon). None srid int Table's SRID None geometry_column str Name of the geomtry column in the table. None properties Dict Properties available in the table. None","title":"Attributes"},{"location":"api/timvt/layer/#ancestors-in-mro_2","text":"timvt.layer.Layer pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/layer/#class-variables_2","text":"Config","title":"Class variables"},{"location":"api/timvt/layer/#static-methods_2","text":"","title":"Static methods"},{"location":"api/timvt/layer/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/layer/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/layer/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/layer/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/layer/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/layer/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/layer/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/layer/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/layer/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/layer/#methods_2","text":"","title":"Methods"},{"location":"api/timvt/layer/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/layer/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/layer/#get_tile_2","text":"def get_tile ( self , pool : buildpg . asyncpg . BuildPgPool , tile : morecantile . commons . Tile , tms : morecantile . models . TileMatrixSet , ** kwargs : Any ) Get Tile Data.","title":"get_tile"},{"location":"api/timvt/layer/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/settings/","text":"Module timvt.settings \u00b6 TiMVT config. TiVTiler uses starlette.config to either get settings from .env or environment variables see: www.starlette.io/config/ Variables \u00b6 APP_NAME CORS_ORIGINS DATABASE_URL DB_MAX_CONN_SIZE DB_MAX_INACTIVE_CONN_LIFETIME DB_MAX_QUERIES DB_MIN_CONN_SIZE DEBUG DEFAULT_MAXZOOM DEFAULT_MINZOOM MAX_FEATURES_PER_TILE TILE_BUFFER TILE_RESOLUTION config","title":"settings"},{"location":"api/timvt/settings/#module-timvtsettings","text":"TiMVT config. TiVTiler uses starlette.config to either get settings from .env or environment variables see: www.starlette.io/config/","title":"Module timvt.settings"},{"location":"api/timvt/settings/#variables","text":"APP_NAME CORS_ORIGINS DATABASE_URL DB_MAX_CONN_SIZE DB_MAX_INACTIVE_CONN_LIFETIME DB_MAX_QUERIES DB_MIN_CONN_SIZE DEBUG DEFAULT_MAXZOOM DEFAULT_MINZOOM MAX_FEATURES_PER_TILE TILE_BUFFER TILE_RESOLUTION config","title":"Variables"},{"location":"api/timvt/models/OGC/","text":"Module timvt.models.OGC \u00b6 timvt.models.OGC: Open GeoSpatial Consortium models. None Classes \u00b6 TileMatrixSetLink \u00b6 class TileMatrixSetLink ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . TileMatrixSetList \u00b6 class TileMatrixSetList ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . TileMatrixSetRef \u00b6 class TileMatrixSetRef ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"OGC"},{"location":"api/timvt/models/OGC/#module-timvtmodelsogc","text":"timvt.models.OGC: Open GeoSpatial Consortium models. None","title":"Module timvt.models.OGC"},{"location":"api/timvt/models/OGC/#classes","text":"","title":"Classes"},{"location":"api/timvt/models/OGC/#tilematrixsetlink","text":"class TileMatrixSetLink ( __pydantic_self__ , ** data : Any )","title":"TileMatrixSetLink"},{"location":"api/timvt/models/OGC/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/models/OGC/#class-variables","text":"Config","title":"Class variables"},{"location":"api/timvt/models/OGC/#static-methods","text":"","title":"Static methods"},{"location":"api/timvt/models/OGC/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/models/OGC/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/models/OGC/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/models/OGC/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/models/OGC/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/models/OGC/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/models/OGC/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/models/OGC/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/models/OGC/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/models/OGC/#methods","text":"","title":"Methods"},{"location":"api/timvt/models/OGC/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/models/OGC/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/models/OGC/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/models/OGC/#tilematrixsetlist","text":"class TileMatrixSetList ( __pydantic_self__ , ** data : Any )","title":"TileMatrixSetList"},{"location":"api/timvt/models/OGC/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/models/OGC/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/timvt/models/OGC/#static-methods_1","text":"","title":"Static methods"},{"location":"api/timvt/models/OGC/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/models/OGC/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/models/OGC/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/models/OGC/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/models/OGC/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/models/OGC/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/models/OGC/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/models/OGC/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/models/OGC/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/models/OGC/#methods_1","text":"","title":"Methods"},{"location":"api/timvt/models/OGC/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/models/OGC/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/models/OGC/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/models/OGC/#tilematrixsetref","text":"class TileMatrixSetRef ( __pydantic_self__ , ** data : Any )","title":"TileMatrixSetRef"},{"location":"api/timvt/models/OGC/#ancestors-in-mro_2","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/models/OGC/#class-variables_2","text":"Config","title":"Class variables"},{"location":"api/timvt/models/OGC/#static-methods_2","text":"","title":"Static methods"},{"location":"api/timvt/models/OGC/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/models/OGC/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/models/OGC/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/models/OGC/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/models/OGC/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/models/OGC/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/models/OGC/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/models/OGC/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/models/OGC/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/models/OGC/#methods_2","text":"","title":"Methods"},{"location":"api/timvt/models/OGC/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/models/OGC/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/models/OGC/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/models/mapbox/","text":"Module timvt.models.mapbox \u00b6 Tilejson response models. None Classes \u00b6 SchemeEnum \u00b6 class SchemeEnum ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 name tms value xyz TileJSON \u00b6 class TileJSON ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 compute_center \u00b6 def compute_center ( values ) Compute center if it does not exist. construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"mapbox"},{"location":"api/timvt/models/mapbox/#module-timvtmodelsmapbox","text":"Tilejson response models. None","title":"Module timvt.models.mapbox"},{"location":"api/timvt/models/mapbox/#classes","text":"","title":"Classes"},{"location":"api/timvt/models/mapbox/#schemeenum","text":"class SchemeEnum ( / , * args , ** kwargs )","title":"SchemeEnum"},{"location":"api/timvt/models/mapbox/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/timvt/models/mapbox/#class-variables","text":"name tms value xyz","title":"Class variables"},{"location":"api/timvt/models/mapbox/#tilejson","text":"class TileJSON ( __pydantic_self__ , ** data : Any )","title":"TileJSON"},{"location":"api/timvt/models/mapbox/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/timvt/models/mapbox/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/timvt/models/mapbox/#static-methods","text":"","title":"Static methods"},{"location":"api/timvt/models/mapbox/#compute_center","text":"def compute_center ( values ) Compute center if it does not exist.","title":"compute_center"},{"location":"api/timvt/models/mapbox/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/timvt/models/mapbox/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/timvt/models/mapbox/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/timvt/models/mapbox/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/timvt/models/mapbox/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/timvt/models/mapbox/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/timvt/models/mapbox/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/timvt/models/mapbox/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/timvt/models/mapbox/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/timvt/models/mapbox/#methods","text":"","title":"Methods"},{"location":"api/timvt/models/mapbox/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/timvt/models/mapbox/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/timvt/models/mapbox/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/timvt/resources/enums/","text":"Module timvt.resources.enums \u00b6 timvt.resources.enums. None Classes \u00b6 MimeTypes \u00b6 class MimeTypes ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 geojson html json mvt name pbf text value xml VectorType \u00b6 class VectorType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 mvt name pbf value","title":"enums"},{"location":"api/timvt/resources/enums/#module-timvtresourcesenums","text":"timvt.resources.enums. None","title":"Module timvt.resources.enums"},{"location":"api/timvt/resources/enums/#classes","text":"","title":"Classes"},{"location":"api/timvt/resources/enums/#mimetypes","text":"class MimeTypes ( / , * args , ** kwargs )","title":"MimeTypes"},{"location":"api/timvt/resources/enums/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/timvt/resources/enums/#class-variables","text":"geojson html json mvt name pbf text value xml","title":"Class variables"},{"location":"api/timvt/resources/enums/#vectortype","text":"class VectorType ( / , * args , ** kwargs )","title":"VectorType"},{"location":"api/timvt/resources/enums/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/timvt/resources/enums/#class-variables_1","text":"mvt name pbf value","title":"Class variables"}]}